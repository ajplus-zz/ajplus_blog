import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,d as t}from"./app-34010d88.js";const e={},c=t(`<h3 id="隐式转换" tabindex="-1"><a class="header-anchor" href="#隐式转换" aria-hidden="true">#</a> 隐式转换</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">byte</span> <span class="token operator">&lt;</span> <span class="token keyword">short</span> <span class="token operator">&lt;</span> <span class="token keyword">int</span> <span class="token operator">&lt;</span> <span class="token keyword">long</span> <span class="token operator">&lt;</span> <span class="token keyword">float</span> <span class="token operator">&lt;</span> <span class="token keyword">double</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意：<code>byte、short、char </code>三种类型的数据在运算的时候，都会直接先提升为<code>int</code>，然后再进行运算；</p><h3 id="与equals" tabindex="-1"><a class="header-anchor" href="#与equals" aria-hidden="true">#</a> == 与equals</h3><p><code>==</code>比较两个变量对象在内存中的首地址，但在自动装箱和拆箱的过程中，对于像<code>Integer</code>这样的包装器类，在<code>-128 - 127</code>这个范围内的值会存在对象池优化，这意味着在这个范围内用<code>==</code>比较可能得到内容相等的结果；</p><p><code>equals()</code>比较字符串中所包含的内容是否相同；（<code>String</code>类已经正确地重写了<code>equals()</code>方法和<code>hashCode()</code>方法）</p><p>在java中，比较对象的内容是否相等（而不是它们在内存中的位置）时，通常需要重写<code>equals()</code>方法以及<code>hashCode()</code>方法；这是因为Object类本身提供的<code>equals()</code>方法默认实现是比较两个对象引用的地址；</p><h3 id="可变参数" tabindex="-1"><a class="header-anchor" href="#可变参数" aria-hidden="true">#</a> 可变参数</h3><p>本质为一个数组，作用：在形参中接受多个数据；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">getSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> arg <span class="token operator">:</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sum <span class="token operator">+=</span> arg<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 限制泛型方法的泛型类型为Number
 */</span>
<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">T</span> arg <span class="token operator">:</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：实际开发过程中建议使用集合类（如List、Set）或者重载方法接收参数；</p><h3 id="堆和栈" tabindex="-1"><a class="header-anchor" href="#堆和栈" aria-hidden="true">#</a> 堆和栈</h3><p><strong>栈</strong>：</p><ul><li>栈的存取速度⽐堆快，仅次于直接位于CPU的寄存器；</li><li>栈中的数据的⼤⼩和⽣存周期是确定的；</li><li>栈中的数据可以共享；</li></ul><p><strong>堆</strong>：</p><ul><li>堆可以动态的分配内存⼤⼩，⽣存期也不必告诉编译器；</li><li>堆在运⾏时动态分配内存，存取速度慢；</li></ul><p>综上所述，可以简单的理解为，为了⾼效，可以把⼀些数值⼩，简单的变量存放在栈中；</p><h3 id="数组与集合" tabindex="-1"><a class="header-anchor" href="#数组与集合" aria-hidden="true">#</a> 数组与集合</h3><p><strong>数组</strong> (<code>Array</code>)</p><ul><li>固定大小：数组在创建时就需要指定其长度，一旦创建，这个长度就是固定的，无法更改；</li><li>类型统一：数组中的所有元素必须是同一类型。</li><li>性能：由于数组是基于索引访问的（直接内存访问），所以在随机访问元素时速度非常快。但是插入、删除操作效率较低；</li><li>简单易用：对于简单的、固定大小的数据集，数组是一种直观且容易使用的数据结构。</li></ul><p><strong>集合</strong> (<code>Collection</code>)</p><p>集合是Java提供的一个更高级的数据结构接口，它包含多个实现类，如List、Set、Queue等，相比数组提供了更多的功能和灵活性。</p><ul><li>动态大小：允许你在运行时动态地添加或删除元素，无需预先确定容量。</li><li>丰富的操作功能：集合框架提供了丰富的API，包括排序、搜索、迭代等高级操作，使得处理数据更加方便。</li><li>性能：集合的性能取决于具体实现。<code>ArrayList</code>在随机访问上接近数组的性能，而LinkedList在插入和删除操作上性能较好；</li></ul><h3 id="权限修饰符" tabindex="-1"><a class="header-anchor" href="#权限修饰符" aria-hidden="true">#</a> 权限修饰符</h3><table><thead><tr><th></th><th style="text-align:center;">同一类中</th><th style="text-align:center;">同一包中的类</th><th style="text-align:center;">不同包的子类</th><th style="text-align:center;">不同包中的无关类</th></tr></thead><tbody><tr><td><code>public</code></td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td></tr><tr><td><code>protected</code></td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;"></td></tr><tr><td>不加修饰符（接口用的多）</td><td style="text-align:center;">✔️</td><td style="text-align:center;">✔️</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td><code>private</code></td><td style="text-align:center;">✔️</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr></tbody></table><p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p><ul><li>成员变量使用<code>private</code> ，隐藏细节；</li><li>构造方法使用<code> public</code> ，方便创建对象；</li><li>成员方法使用<code>public</code> ，方便调用方法；</li><li>当希望某个成员可以在继承体系内被访问，同时保持对包外的不可见性时使用<code>protected</code>；</li></ul>`,27),o=[c];function l(p,i){return a(),s("div",null,o)}const u=n(e,[["render",l],["__file","ch1.html.vue"]]);export{u as default};
