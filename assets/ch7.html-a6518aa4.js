import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{o as c,c as e,d as t}from"./app-34010d88.js";const p={},i=t("<p>悲观锁和乐观锁是在并发编程中用于解决数据竞争问题的两种不同的策略；它们的主要区别基于对共享资源（如数据）被并发修改的概率的不同假设，以及对冲突解决的方法；</p><p><strong>悲观锁</strong>：（<code>Pessimistic Locking</code>）</p><p>悲观锁假设在多数情况下，多个事务并发访问同一数据时可能会发生冲突，因此在实际修改数据之前，它会先获取数据锁；这样做可以保证同一时间只有一个事务能修改数据，从而防止了冲突；如果在获取锁时遇到其他事务已经持有了该锁，那么当前事务会被阻塞，直到锁被释放；</p><ul><li>在数据库层面，悲观锁通常通过<code>SELECT FOR UPDATE</code>语句实现，它会锁定选中的数据行，直到事务结束；</li><li>在编程语言中，如java，可以通过<code>synchronized</code>关键字或<code>ReentrantLock</code>实现悲观锁；</li></ul><p>优点：简单直接，容易理解；在冲突比较频繁的环境中可以有效避免数据不一致；</p><p>缺点：可能会导致死锁；在高并发环境下可能会导致大量的锁等待，降低系统性能；</p><p>适用场景：写操作频繁，冲突可能性高的场景；</p><p><strong>乐观锁</strong>：（<code>Optimistic Locking</code>）</p><p>乐观锁则持相反的观点，它假设多个事务并发访问同一数据时不太可能发生冲突，因此在实际修改数据之前不会先获取锁；它只在提交事务时检查数据版本号或时间戳，以确定数据在事务开始到提交期间是否被其他事务修改过；如果检测到冲突，乐观锁会拒绝更改并通常会重试；</p><ul><li>在数据库层面，乐观锁可以通过版本字段或时间戳字段实现，这些字段在每次更新时会递增；</li><li>在编程语言中，可以使用无锁数据结构或<code>CAS</code>算法实现乐观锁；</li></ul><p>优点：在冲突较少的环境中可以减少锁的开销，提高系统吞吐量；通常不会导致死锁；</p><p>缺点：在冲突比较频繁的环境中，可能会导致大量的重试和失败，降低性能；实现较为复杂；</p><p>适用场景：适用于读操作远多于写操作，冲突较少的场景；</p>",13),n=[i];function s(d,l){return c(),e("div",null,n)}const a=o(p,[["render",s],["__file","ch7.html.vue"]]);export{a as default};
